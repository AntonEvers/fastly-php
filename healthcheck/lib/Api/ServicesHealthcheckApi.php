<?php
/**
 * ServicesHealthcheckApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Healthcheck
 *
 * Healthchecks are used to customize the way Fastly checks on your Backends. If an origin server is marked unhealthy due to health checks, Fastly will stop attempting to send requests to it. If all origin servers are marked unhealthy, Fastly will attempt to serve stale. If no stale object is available, a 503 will be returned to the client.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ServicesHealthcheckApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ServicesHealthcheckApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createHealthcheck
     *
     * Create a healthcheck
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject
     */
    public function createHealthcheck($service_id, $version_id, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        list($response) = $this->createHealthcheckWithHttpInfo($service_id, $version_id, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);
        return $response;
    }

    /**
     * Operation createHealthcheckWithHttpInfo
     *
     * Create a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function createHealthcheckWithHttpInfo($service_id, $version_id, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        $request = $this->createHealthcheckRequest($service_id, $version_id, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createHealthcheckAsync
     *
     * Create a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHealthcheckAsync($service_id, $version_id, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        return $this->createHealthcheckAsyncWithHttpInfo($service_id, $version_id, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createHealthcheckAsyncWithHttpInfo
     *
     * Create a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHealthcheckAsyncWithHttpInfo($service_id, $version_id, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject';
        $request = $this->createHealthcheckRequest($service_id, $version_id, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createHealthcheck'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createHealthcheckRequest($service_id, $version_id, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling createHealthcheck'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling createHealthcheck'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/healthcheck';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($version !== null) {
            $formParams['version'] = ObjectSerializer::toFormValue($version);
        }
        // form params
        if ($check_interval !== null) {
            $formParams['check_interval'] = ObjectSerializer::toFormValue($check_interval);
        }
        // form params
        if ($comment !== null) {
            $formParams['comment'] = ObjectSerializer::toFormValue($comment);
        }
        // form params
        if ($expected_response !== null) {
            $formParams['expected_response'] = ObjectSerializer::toFormValue($expected_response);
        }
        // form params
        if ($host !== null) {
            $formParams['host'] = ObjectSerializer::toFormValue($host);
        }
        // form params
        if ($http_version !== null) {
            $formParams['http_version'] = ObjectSerializer::toFormValue($http_version);
        }
        // form params
        if ($initial !== null) {
            $formParams['initial'] = ObjectSerializer::toFormValue($initial);
        }
        // form params
        if ($method !== null) {
            $formParams['method'] = ObjectSerializer::toFormValue($method);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($threshold !== null) {
            $formParams['threshold'] = ObjectSerializer::toFormValue($threshold);
        }
        // form params
        if ($timeout !== null) {
            $formParams['timeout'] = ObjectSerializer::toFormValue($timeout);
        }
        // form params
        if ($window !== null) {
            $formParams['window'] = ObjectSerializer::toFormValue($window);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteHealthcheck
     *
     * Delete a healthcheck
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $healthcheck_name healthcheck_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteHealthcheck($service_id, $version_id, $healthcheck_name)
    {
        list($response) = $this->deleteHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name);
        return $response;
    }

    /**
     * Operation deleteHealthcheckWithHttpInfo
     *
     * Delete a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name)
    {
        $request = $this->deleteHealthcheckRequest($service_id, $version_id, $healthcheck_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteHealthcheckAsync
     *
     * Delete a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHealthcheckAsync($service_id, $version_id, $healthcheck_name)
    {
        return $this->deleteHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteHealthcheckAsyncWithHttpInfo
     *
     * Delete a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name)
    {
        $returnType = 'object';
        $request = $this->deleteHealthcheckRequest($service_id, $version_id, $healthcheck_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteHealthcheck'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteHealthcheckRequest($service_id, $version_id, $healthcheck_name)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling deleteHealthcheck'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteHealthcheck'
            );
        }
        // verify the required parameter 'healthcheck_name' is set
        if ($healthcheck_name === null || (is_array($healthcheck_name) && count($healthcheck_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $healthcheck_name when calling deleteHealthcheck'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/healthcheck/{healthcheck_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($healthcheck_name !== null) {
            $resourcePath = str_replace(
                '{' . 'healthcheck_name' . '}',
                ObjectSerializer::toPathValue($healthcheck_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHealthcheck
     *
     * Get a healthcheck
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $healthcheck_name healthcheck_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject
     */
    public function getHealthcheck($service_id, $version_id, $healthcheck_name)
    {
        list($response) = $this->getHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name);
        return $response;
    }

    /**
     * Operation getHealthcheckWithHttpInfo
     *
     * Get a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name)
    {
        $request = $this->getHealthcheckRequest($service_id, $version_id, $healthcheck_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHealthcheckAsync
     *
     * Get a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHealthcheckAsync($service_id, $version_id, $healthcheck_name)
    {
        return $this->getHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHealthcheckAsyncWithHttpInfo
     *
     * Get a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name)
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject';
        $request = $this->getHealthcheckRequest($service_id, $version_id, $healthcheck_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHealthcheck'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHealthcheckRequest($service_id, $version_id, $healthcheck_name)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling getHealthcheck'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getHealthcheck'
            );
        }
        // verify the required parameter 'healthcheck_name' is set
        if ($healthcheck_name === null || (is_array($healthcheck_name) && count($healthcheck_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $healthcheck_name when calling getHealthcheck'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/healthcheck/{healthcheck_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($healthcheck_name !== null) {
            $resourcePath = str_replace(
                '{' . 'healthcheck_name' . '}',
                ObjectSerializer::toPathValue($healthcheck_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listHealthchecks
     *
     * List healthchecks
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse200[]
     */
    public function listHealthchecks($service_id, $version_id)
    {
        list($response) = $this->listHealthchecksWithHttpInfo($service_id, $version_id);
        return $response;
    }

    /**
     * Operation listHealthchecksWithHttpInfo
     *
     * List healthchecks
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse200[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listHealthchecksWithHttpInfo($service_id, $version_id)
    {
        $request = $this->listHealthchecksRequest($service_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse200[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse200[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse200[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse200[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listHealthchecksAsync
     *
     * List healthchecks
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHealthchecksAsync($service_id, $version_id)
    {
        return $this->listHealthchecksAsyncWithHttpInfo($service_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listHealthchecksAsyncWithHttpInfo
     *
     * List healthchecks
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHealthchecksAsyncWithHttpInfo($service_id, $version_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse200[]';
        $request = $this->listHealthchecksRequest($service_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listHealthchecks'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listHealthchecksRequest($service_id, $version_id)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling listHealthchecks'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling listHealthchecks'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/healthcheck';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHealthcheck
     *
     * Update a healthcheck
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $healthcheck_name healthcheck_name (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject1
     */
    public function updateHealthcheck($service_id, $version_id, $healthcheck_name, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        list($response) = $this->updateHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);
        return $response;
    }

    /**
     * Operation updateHealthcheckWithHttpInfo
     *
     * Update a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject1, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHealthcheckWithHttpInfo($service_id, $version_id, $healthcheck_name, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        $request = $this->updateHealthcheckRequest($service_id, $version_id, $healthcheck_name, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineObject1' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineObject1', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineObject1';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateHealthcheckAsync
     *
     * Update a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHealthcheckAsync($service_id, $version_id, $healthcheck_name, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        return $this->updateHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHealthcheckAsyncWithHttpInfo
     *
     * Update a healthcheck
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHealthcheckAsyncWithHttpInfo($service_id, $version_id, $healthcheck_name, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject1';
        $request = $this->updateHealthcheckRequest($service_id, $version_id, $healthcheck_name, $service_id2, $version, $check_interval, $comment, $expected_response, $host, $http_version, $initial, $method, $name, $path, $threshold, $timeout, $window);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHealthcheck'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $healthcheck_name (required)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  int $check_interval How often to run the healthcheck in milliseconds. (optional)
     * @param  string $comment A freeform descriptive note. (optional, default to '')
     * @param  int $expected_response The status code expected from the host. (optional)
     * @param  string $host Which host to check. (optional)
     * @param  string $http_version Whether to use version 1.0 or 1.1 HTTP. (optional)
     * @param  int $initial When loading a config, the initial number of probes to be seen as OK. (optional)
     * @param  string $method Which HTTP method to use. (optional)
     * @param  string $name The name of the healthcheck. (optional)
     * @param  string $path The path to check. (optional)
     * @param  int $threshold How many healthchecks must succeed to be considered healthy. (optional)
     * @param  int $timeout Timeout in milliseconds. (optional)
     * @param  int $window The number of most recent healthcheck queries to keep for this healthcheck. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateHealthcheckRequest($service_id, $version_id, $healthcheck_name, $service_id2 = null, $version = null, $check_interval = null, $comment = '', $expected_response = null, $host = null, $http_version = null, $initial = null, $method = null, $name = null, $path = null, $threshold = null, $timeout = null, $window = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling updateHealthcheck'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling updateHealthcheck'
            );
        }
        // verify the required parameter 'healthcheck_name' is set
        if ($healthcheck_name === null || (is_array($healthcheck_name) && count($healthcheck_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $healthcheck_name when calling updateHealthcheck'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/healthcheck/{healthcheck_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($healthcheck_name !== null) {
            $resourcePath = str_replace(
                '{' . 'healthcheck_name' . '}',
                ObjectSerializer::toPathValue($healthcheck_name),
                $resourcePath
            );
        }

        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($version !== null) {
            $formParams['version'] = ObjectSerializer::toFormValue($version);
        }
        // form params
        if ($check_interval !== null) {
            $formParams['check_interval'] = ObjectSerializer::toFormValue($check_interval);
        }
        // form params
        if ($comment !== null) {
            $formParams['comment'] = ObjectSerializer::toFormValue($comment);
        }
        // form params
        if ($expected_response !== null) {
            $formParams['expected_response'] = ObjectSerializer::toFormValue($expected_response);
        }
        // form params
        if ($host !== null) {
            $formParams['host'] = ObjectSerializer::toFormValue($host);
        }
        // form params
        if ($http_version !== null) {
            $formParams['http_version'] = ObjectSerializer::toFormValue($http_version);
        }
        // form params
        if ($initial !== null) {
            $formParams['initial'] = ObjectSerializer::toFormValue($initial);
        }
        // form params
        if ($method !== null) {
            $formParams['method'] = ObjectSerializer::toFormValue($method);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($threshold !== null) {
            $formParams['threshold'] = ObjectSerializer::toFormValue($threshold);
        }
        // form params
        if ($timeout !== null) {
            $formParams['timeout'] = ObjectSerializer::toFormValue($timeout);
        }
        // form params
        if ($window !== null) {
            $formParams['window'] = ObjectSerializer::toFormValue($window);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

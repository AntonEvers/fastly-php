<?php
/**
 * DictionaryItemApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Fastly API
 *
 * Via the Fastly API you can perform any of the operations that are possible within the management console,  including creating services, domains, and backends, configuring rules or uploading your own application code, as well as account operations such as user administration and billing reports. The API is organized into collections of endpoints that allow manipulation of objects related to Fastly services and accounts. For the most accurate and up-to-date API reference content, visit developer.fastly.com/reference/api/
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DictionaryItemApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DictionaryItemApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bulkUpdateDictionaryItem
     *
     * Update multiple entries in an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject1 $inline_object1 inline_object1 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function bulkUpdateDictionaryItem($service_id, $dictionary_id, $inline_object1 = null)
    {
        list($response) = $this->bulkUpdateDictionaryItemWithHttpInfo($service_id, $dictionary_id, $inline_object1);
        return $response;
    }

    /**
     * Operation bulkUpdateDictionaryItemWithHttpInfo
     *
     * Update multiple entries in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject1 $inline_object1 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateDictionaryItemWithHttpInfo($service_id, $dictionary_id, $inline_object1 = null)
    {
        $request = $this->bulkUpdateDictionaryItemRequest($service_id, $dictionary_id, $inline_object1);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateDictionaryItemAsync
     *
     * Update multiple entries in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject1 $inline_object1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateDictionaryItemAsync($service_id, $dictionary_id, $inline_object1 = null)
    {
        return $this->bulkUpdateDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $inline_object1)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateDictionaryItemAsyncWithHttpInfo
     *
     * Update multiple entries in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject1 $inline_object1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $inline_object1 = null)
    {
        $returnType = 'object';
        $request = $this->bulkUpdateDictionaryItemRequest($service_id, $dictionary_id, $inline_object1);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  \OpenAPI\Client\Model\InlineObject1 $inline_object1 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateDictionaryItemRequest($service_id, $dictionary_id, $inline_object1 = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling bulkUpdateDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling bulkUpdateDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inline_object1)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inline_object1));
            } else {
                $httpBody = $inline_object1;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDictionaryItem
     *
     * Create an entry in an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelDictionaryItem
     */
    public function createDictionaryItem($service_id, $dictionary_id, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        list($response) = $this->createDictionaryItemWithHttpInfo($service_id, $dictionary_id, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);
        return $response;
    }

    /**
     * Operation createDictionaryItemWithHttpInfo
     *
     * Create an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelDictionaryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDictionaryItemWithHttpInfo($service_id, $dictionary_id, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $request = $this->createDictionaryItemRequest($service_id, $dictionary_id, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelDictionaryItem' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelDictionaryItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelDictionaryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDictionaryItemAsync
     *
     * Create an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDictionaryItemAsync($service_id, $dictionary_id, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        return $this->createDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDictionaryItemAsyncWithHttpInfo
     *
     * Create an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
        $request = $this->createDictionaryItemRequest($service_id, $dictionary_id, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDictionaryItemRequest($service_id, $dictionary_id, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling createDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling createDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }

        // form params
        if ($created_at !== null) {
            $formParams['created_at'] = ObjectSerializer::toFormValue($created_at);
        }
        // form params
        if ($deleted_at !== null) {
            $formParams['deleted_at'] = ObjectSerializer::toFormValue($deleted_at);
        }
        // form params
        if ($updated_at !== null) {
            $formParams['updated_at'] = ObjectSerializer::toFormValue($updated_at);
        }
        // form params
        if ($dictionary_id2 !== null) {
            $formParams['dictionary_id'] = ObjectSerializer::toFormValue($dictionary_id2);
        }
        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($item_key !== null) {
            $formParams['item_key'] = ObjectSerializer::toFormValue($item_key);
        }
        // form params
        if ($item_value !== null) {
            $formParams['item_value'] = ObjectSerializer::toFormValue($item_value);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDictionaryItem
     *
     * Delete an item from an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  string $dictionary_item_key dictionary_item_key (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteDictionaryItem($service_id, $dictionary_id, $dictionary_item_key)
    {
        list($response) = $this->deleteDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key);
        return $response;
    }

    /**
     * Operation deleteDictionaryItemWithHttpInfo
     *
     * Delete an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
    {
        $request = $this->deleteDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDictionaryItemAsync
     *
     * Delete an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDictionaryItemAsync($service_id, $dictionary_id, $dictionary_item_key)
    {
        return $this->deleteDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDictionaryItemAsyncWithHttpInfo
     *
     * Delete an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
    {
        $returnType = 'object';
        $request = $this->deleteDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling deleteDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling deleteDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_item_key' is set
        if ($dictionary_item_key === null || (is_array($dictionary_item_key) && count($dictionary_item_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_item_key when calling deleteDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/item/{dictionary_item_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_item_key !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_item_key' . '}',
                ObjectSerializer::toPathValue($dictionary_item_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDictionaryItem
     *
     * Get an item from an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  string $dictionary_item_key dictionary_item_key (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelDictionaryItem
     */
    public function getDictionaryItem($service_id, $dictionary_id, $dictionary_item_key)
    {
        list($response) = $this->getDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key);
        return $response;
    }

    /**
     * Operation getDictionaryItemWithHttpInfo
     *
     * Get an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelDictionaryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
    {
        $request = $this->getDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelDictionaryItem' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelDictionaryItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelDictionaryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDictionaryItemAsync
     *
     * Get an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDictionaryItemAsync($service_id, $dictionary_id, $dictionary_item_key)
    {
        return $this->getDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDictionaryItemAsyncWithHttpInfo
     *
     * Get an item from an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key)
    {
        $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
        $request = $this->getDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling getDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling getDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_item_key' is set
        if ($dictionary_item_key === null || (is_array($dictionary_item_key) && count($dictionary_item_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_item_key when calling getDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/item/{dictionary_item_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_item_key !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_item_key' . '}',
                ObjectSerializer::toPathValue($dictionary_item_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDictionaryItems
     *
     * List items in an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  int $page Current page. (optional)
     * @param  int $per_page Number of records per page. (optional, default to 20)
     * @param  string $sort Field on which to sort. (optional, default to 'created')
     * @param  \OpenAPI\Client\Model\Direction $direction Direction in which to sort results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelDictionaryItem[]
     */
    public function listDictionaryItems($service_id, $dictionary_id, $page = null, $per_page = 20, $sort = 'created', $direction = null)
    {
        list($response) = $this->listDictionaryItemsWithHttpInfo($service_id, $dictionary_id, $page, $per_page, $sort, $direction);
        return $response;
    }

    /**
     * Operation listDictionaryItemsWithHttpInfo
     *
     * List items in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  int $page Current page. (optional)
     * @param  int $per_page Number of records per page. (optional, default to 20)
     * @param  string $sort Field on which to sort. (optional, default to 'created')
     * @param  \OpenAPI\Client\Model\Direction $direction Direction in which to sort results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelDictionaryItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listDictionaryItemsWithHttpInfo($service_id, $dictionary_id, $page = null, $per_page = 20, $sort = 'created', $direction = null)
    {
        $request = $this->listDictionaryItemsRequest($service_id, $dictionary_id, $page, $per_page, $sort, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelDictionaryItem[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelDictionaryItem[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelDictionaryItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDictionaryItemsAsync
     *
     * List items in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  int $page Current page. (optional)
     * @param  int $per_page Number of records per page. (optional, default to 20)
     * @param  string $sort Field on which to sort. (optional, default to 'created')
     * @param  \OpenAPI\Client\Model\Direction $direction Direction in which to sort results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDictionaryItemsAsync($service_id, $dictionary_id, $page = null, $per_page = 20, $sort = 'created', $direction = null)
    {
        return $this->listDictionaryItemsAsyncWithHttpInfo($service_id, $dictionary_id, $page, $per_page, $sort, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDictionaryItemsAsyncWithHttpInfo
     *
     * List items in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  int $page Current page. (optional)
     * @param  int $per_page Number of records per page. (optional, default to 20)
     * @param  string $sort Field on which to sort. (optional, default to 'created')
     * @param  \OpenAPI\Client\Model\Direction $direction Direction in which to sort results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDictionaryItemsAsyncWithHttpInfo($service_id, $dictionary_id, $page = null, $per_page = 20, $sort = 'created', $direction = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem[]';
        $request = $this->listDictionaryItemsRequest($service_id, $dictionary_id, $page, $per_page, $sort, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDictionaryItems'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  int $page Current page. (optional)
     * @param  int $per_page Number of records per page. (optional, default to 20)
     * @param  string $sort Field on which to sort. (optional, default to 'created')
     * @param  \OpenAPI\Client\Model\Direction $direction Direction in which to sort results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDictionaryItemsRequest($service_id, $dictionary_id, $page = null, $per_page = 20, $sort = 'created', $direction = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling listDictionaryItems'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling listDictionaryItems'
            );
        }
        if ($per_page !== null && $per_page < 1) {
            throw new \InvalidArgumentException('invalid value for "$per_page" when calling DictionaryItemApi.listDictionaryItems, must be bigger than or equal to 1.');
        }


        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, 'simple', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($per_page)) {
            $per_page = ObjectSerializer::serializeCollection($per_page, 'simple', true);
        }
        if ($per_page !== null) {
            $queryParams['per_page'] = $per_page;
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, 'simple', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = $sort;
        }
        // query params
        if (is_array($direction)) {
            $direction = ObjectSerializer::serializeCollection($direction, 'simple', true);
        }
        if ($direction !== null) {
            $queryParams['direction'] = $direction;
        }


        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDictionaryItem
     *
     * Update an entry in an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  string $dictionary_item_key dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelDictionaryItem
     */
    public function updateDictionaryItem($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        list($response) = $this->updateDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);
        return $response;
    }

    /**
     * Operation updateDictionaryItemWithHttpInfo
     *
     * Update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelDictionaryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $request = $this->updateDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelDictionaryItem' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelDictionaryItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelDictionaryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDictionaryItemAsync
     *
     * Update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDictionaryItemAsync($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        return $this->updateDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDictionaryItemAsyncWithHttpInfo
     *
     * Update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
        $request = $this->updateDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling updateDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling updateDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_item_key' is set
        if ($dictionary_item_key === null || (is_array($dictionary_item_key) && count($dictionary_item_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_item_key when calling updateDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/item/{dictionary_item_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_item_key !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_item_key' . '}',
                ObjectSerializer::toPathValue($dictionary_item_key),
                $resourcePath
            );
        }

        // form params
        if ($created_at !== null) {
            $formParams['created_at'] = ObjectSerializer::toFormValue($created_at);
        }
        // form params
        if ($deleted_at !== null) {
            $formParams['deleted_at'] = ObjectSerializer::toFormValue($deleted_at);
        }
        // form params
        if ($updated_at !== null) {
            $formParams['updated_at'] = ObjectSerializer::toFormValue($updated_at);
        }
        // form params
        if ($dictionary_id2 !== null) {
            $formParams['dictionary_id'] = ObjectSerializer::toFormValue($dictionary_id2);
        }
        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($item_key !== null) {
            $formParams['item_key'] = ObjectSerializer::toFormValue($item_key);
        }
        // form params
        if ($item_value !== null) {
            $formParams['item_value'] = ObjectSerializer::toFormValue($item_value);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation upsertDictionaryItem
     *
     * Insert or update an entry in an edge dictionary
     *
     * @param  string $service_id service_id (required)
     * @param  string $dictionary_id dictionary_id (required)
     * @param  string $dictionary_item_key dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelDictionaryItem
     */
    public function upsertDictionaryItem($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        list($response) = $this->upsertDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);
        return $response;
    }

    /**
     * Operation upsertDictionaryItemWithHttpInfo
     *
     * Insert or update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelDictionaryItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function upsertDictionaryItemWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $request = $this->upsertDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelDictionaryItem' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelDictionaryItem', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelDictionaryItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation upsertDictionaryItemAsync
     *
     * Insert or update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upsertDictionaryItemAsync($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        return $this->upsertDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation upsertDictionaryItemAsyncWithHttpInfo
     *
     * Insert or update an entry in an edge dictionary
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upsertDictionaryItemAsyncWithHttpInfo($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelDictionaryItem';
        $request = $this->upsertDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at, $deleted_at, $updated_at, $dictionary_id2, $service_id2, $item_key, $item_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upsertDictionaryItem'
     *
     * @param  string $service_id (required)
     * @param  string $dictionary_id (required)
     * @param  string $dictionary_item_key (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $dictionary_id2 Alphanumeric string identifying a Dictionary. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  string $item_key Item key, maximum 256 characters. (optional)
     * @param  string $item_value Item value, maximum 8000 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function upsertDictionaryItemRequest($service_id, $dictionary_id, $dictionary_item_key, $created_at = null, $deleted_at = null, $updated_at = null, $dictionary_id2 = null, $service_id2 = null, $item_key = null, $item_value = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling upsertDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_id' is set
        if ($dictionary_id === null || (is_array($dictionary_id) && count($dictionary_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_id when calling upsertDictionaryItem'
            );
        }
        // verify the required parameter 'dictionary_item_key' is set
        if ($dictionary_item_key === null || (is_array($dictionary_item_key) && count($dictionary_item_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dictionary_item_key when calling upsertDictionaryItem'
            );
        }

        $resourcePath = '/service/{service_id}/dictionary/{dictionary_id}/item/{dictionary_item_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_id' . '}',
                ObjectSerializer::toPathValue($dictionary_id),
                $resourcePath
            );
        }
        // path params
        if ($dictionary_item_key !== null) {
            $resourcePath = str_replace(
                '{' . 'dictionary_item_key' . '}',
                ObjectSerializer::toPathValue($dictionary_item_key),
                $resourcePath
            );
        }

        // form params
        if ($created_at !== null) {
            $formParams['created_at'] = ObjectSerializer::toFormValue($created_at);
        }
        // form params
        if ($deleted_at !== null) {
            $formParams['deleted_at'] = ObjectSerializer::toFormValue($deleted_at);
        }
        // form params
        if ($updated_at !== null) {
            $formParams['updated_at'] = ObjectSerializer::toFormValue($updated_at);
        }
        // form params
        if ($dictionary_id2 !== null) {
            $formParams['dictionary_id'] = ObjectSerializer::toFormValue($dictionary_id2);
        }
        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($item_key !== null) {
            $formParams['item_key'] = ObjectSerializer::toFormValue($item_key);
        }
        // form params
        if ($item_value !== null) {
            $formParams['item_value'] = ObjectSerializer::toFormValue($item_value);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

<?php
/**
 * LoggingFtpApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Fastly API
 *
 * Via the Fastly API you can perform any of the operations that are possible within the management console,  including creating services, domains, and backends, configuring rules or uploading your own application code, as well as account operations such as user administration and billing reports. The API is organized into collections of endpoints that allow manipulation of objects related to Fastly services and accounts. For the most accurate and up-to-date API reference content, visit developer.fastly.com/reference/api/
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * LoggingFtpApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LoggingFtpApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createLogFtp
     *
     * Create an FTP log endpoint
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelLoggingFtp
     */
    public function createLogFtp($service_id, $version_id, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        list($response) = $this->createLogFtpWithHttpInfo($service_id, $version_id, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);
        return $response;
    }

    /**
     * Operation createLogFtpWithHttpInfo
     *
     * Create an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelLoggingFtp, HTTP status code, HTTP response headers (array of strings)
     */
    public function createLogFtpWithHttpInfo($service_id, $version_id, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        $request = $this->createLogFtpRequest($service_id, $version_id, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelLoggingFtp' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelLoggingFtp', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelLoggingFtp',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createLogFtpAsync
     *
     * Create an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLogFtpAsync($service_id, $version_id, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        return $this->createLogFtpAsyncWithHttpInfo($service_id, $version_id, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLogFtpAsyncWithHttpInfo
     *
     * Create an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLogFtpAsyncWithHttpInfo($service_id, $version_id, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
        $request = $this->createLogFtpRequest($service_id, $version_id, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createLogFtp'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createLogFtpRequest($service_id, $version_id, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling createLogFtp'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling createLogFtp'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/logging/ftp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }

        // form params
        if ($created_at !== null) {
            $formParams['created_at'] = ObjectSerializer::toFormValue($created_at);
        }
        // form params
        if ($deleted_at !== null) {
            $formParams['deleted_at'] = ObjectSerializer::toFormValue($deleted_at);
        }
        // form params
        if ($updated_at !== null) {
            $formParams['updated_at'] = ObjectSerializer::toFormValue($updated_at);
        }
        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($version !== null) {
            $formParams['version'] = ObjectSerializer::toFormValue($version);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($placement !== null) {
            $formParams['placement'] = ObjectSerializer::toFormValue($placement);
        }
        // form params
        if ($format_version !== null) {
            $formParams['format_version'] = ObjectSerializer::toFormValue($format_version);
        }
        // form params
        if ($response_condition !== null) {
            $formParams['response_condition'] = ObjectSerializer::toFormValue($response_condition);
        }
        // form params
        if ($format !== null) {
            $formParams['format'] = ObjectSerializer::toFormValue($format);
        }
        // form params
        if ($message_type !== null) {
            $formParams['message_type'] = ObjectSerializer::toFormValue($message_type);
        }
        // form params
        if ($timestamp_format !== null) {
            $formParams['timestamp_format'] = ObjectSerializer::toFormValue($timestamp_format);
        }
        // form params
        if ($period !== null) {
            $formParams['period'] = ObjectSerializer::toFormValue($period);
        }
        // form params
        if ($gzip_level !== null) {
            $formParams['gzip_level'] = ObjectSerializer::toFormValue($gzip_level);
        }
        // form params
        if ($compression_codec !== null) {
            $formParams['compression_codec'] = ObjectSerializer::toFormValue($compression_codec);
        }
        // form params
        if ($address !== null) {
            $formParams['address'] = ObjectSerializer::toFormValue($address);
        }
        // form params
        if ($hostname !== null) {
            $formParams['hostname'] = ObjectSerializer::toFormValue($hostname);
        }
        // form params
        if ($ipv4 !== null) {
            $formParams['ipv4'] = ObjectSerializer::toFormValue($ipv4);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($port !== null) {
            $formParams['port'] = ObjectSerializer::toFormValue($port);
        }
        // form params
        if ($public_key !== null) {
            $formParams['public_key'] = ObjectSerializer::toFormValue($public_key);
        }
        // form params
        if ($user !== null) {
            $formParams['user'] = ObjectSerializer::toFormValue($user);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteLogFtp
     *
     * Delete an FTP log endpoint
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $logging_ftp_name logging_ftp_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteLogFtp($service_id, $version_id, $logging_ftp_name)
    {
        list($response) = $this->deleteLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name);
        return $response;
    }

    /**
     * Operation deleteLogFtpWithHttpInfo
     *
     * Delete an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name)
    {
        $request = $this->deleteLogFtpRequest($service_id, $version_id, $logging_ftp_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteLogFtpAsync
     *
     * Delete an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLogFtpAsync($service_id, $version_id, $logging_ftp_name)
    {
        return $this->deleteLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteLogFtpAsyncWithHttpInfo
     *
     * Delete an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name)
    {
        $returnType = 'object';
        $request = $this->deleteLogFtpRequest($service_id, $version_id, $logging_ftp_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteLogFtp'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteLogFtpRequest($service_id, $version_id, $logging_ftp_name)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling deleteLogFtp'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling deleteLogFtp'
            );
        }
        // verify the required parameter 'logging_ftp_name' is set
        if ($logging_ftp_name === null || (is_array($logging_ftp_name) && count($logging_ftp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logging_ftp_name when calling deleteLogFtp'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/logging/ftp/{logging_ftp_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($logging_ftp_name !== null) {
            $resourcePath = str_replace(
                '{' . 'logging_ftp_name' . '}',
                ObjectSerializer::toPathValue($logging_ftp_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLogFtp
     *
     * Get an FTP log endpoint
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $logging_ftp_name logging_ftp_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelLoggingFtp
     */
    public function getLogFtp($service_id, $version_id, $logging_ftp_name)
    {
        list($response) = $this->getLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name);
        return $response;
    }

    /**
     * Operation getLogFtpWithHttpInfo
     *
     * Get an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelLoggingFtp, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name)
    {
        $request = $this->getLogFtpRequest($service_id, $version_id, $logging_ftp_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelLoggingFtp' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelLoggingFtp', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelLoggingFtp',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLogFtpAsync
     *
     * Get an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLogFtpAsync($service_id, $version_id, $logging_ftp_name)
    {
        return $this->getLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLogFtpAsyncWithHttpInfo
     *
     * Get an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name)
    {
        $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
        $request = $this->getLogFtpRequest($service_id, $version_id, $logging_ftp_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLogFtp'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLogFtpRequest($service_id, $version_id, $logging_ftp_name)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling getLogFtp'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling getLogFtp'
            );
        }
        // verify the required parameter 'logging_ftp_name' is set
        if ($logging_ftp_name === null || (is_array($logging_ftp_name) && count($logging_ftp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logging_ftp_name when calling getLogFtp'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/logging/ftp/{logging_ftp_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($logging_ftp_name !== null) {
            $resourcePath = str_replace(
                '{' . 'logging_ftp_name' . '}',
                ObjectSerializer::toPathValue($logging_ftp_name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLogFtp
     *
     * List FTP log endpoints
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelLoggingFtp[]
     */
    public function listLogFtp($service_id, $version_id)
    {
        list($response) = $this->listLogFtpWithHttpInfo($service_id, $version_id);
        return $response;
    }

    /**
     * Operation listLogFtpWithHttpInfo
     *
     * List FTP log endpoints
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelLoggingFtp[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listLogFtpWithHttpInfo($service_id, $version_id)
    {
        $request = $this->listLogFtpRequest($service_id, $version_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelLoggingFtp[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelLoggingFtp[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelLoggingFtp[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLogFtpAsync
     *
     * List FTP log endpoints
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLogFtpAsync($service_id, $version_id)
    {
        return $this->listLogFtpAsyncWithHttpInfo($service_id, $version_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLogFtpAsyncWithHttpInfo
     *
     * List FTP log endpoints
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLogFtpAsyncWithHttpInfo($service_id, $version_id)
    {
        $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp[]';
        $request = $this->listLogFtpRequest($service_id, $version_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLogFtp'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLogFtpRequest($service_id, $version_id)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling listLogFtp'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling listLogFtp'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/logging/ftp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateLogFtp
     *
     * Update an FTP log endpoint
     *
     * @param  string $service_id service_id (required)
     * @param  int $version_id version_id (required)
     * @param  string $logging_ftp_name logging_ftp_name (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelLoggingFtp
     */
    public function updateLogFtp($service_id, $version_id, $logging_ftp_name, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        list($response) = $this->updateLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);
        return $response;
    }

    /**
     * Operation updateLogFtpWithHttpInfo
     *
     * Update an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelLoggingFtp, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateLogFtpWithHttpInfo($service_id, $version_id, $logging_ftp_name, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        $request = $this->updateLogFtpRequest($service_id, $version_id, $logging_ftp_name, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelLoggingFtp' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelLoggingFtp', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelLoggingFtp',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateLogFtpAsync
     *
     * Update an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLogFtpAsync($service_id, $version_id, $logging_ftp_name, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        return $this->updateLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateLogFtpAsyncWithHttpInfo
     *
     * Update an FTP log endpoint
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateLogFtpAsyncWithHttpInfo($service_id, $version_id, $logging_ftp_name, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        $returnType = '\OpenAPI\Client\Model\ModelLoggingFtp';
        $request = $this->updateLogFtpRequest($service_id, $version_id, $logging_ftp_name, $created_at, $deleted_at, $updated_at, $service_id2, $version, $name, $placement, $format_version, $response_condition, $format, $message_type, $timestamp_format, $period, $gzip_level, $compression_codec, $address, $hostname, $ipv4, $password, $path, $port, $public_key, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateLogFtp'
     *
     * @param  string $service_id (required)
     * @param  int $version_id (required)
     * @param  string $logging_ftp_name (required)
     * @param  string $created_at Date and time in ISO 8601 format. (optional)
     * @param  string $deleted_at Date and time in ISO 8601 format. (optional)
     * @param  string $updated_at Date and time in ISO 8601 format. (optional)
     * @param  string $service_id2 Alphanumeric string identifying the service. (optional)
     * @param  int $version Integer identifying a service version. (optional)
     * @param  string $name The name for the real-time logging configuration. (optional)
     * @param  \OpenAPI\Client\Model\LoggingPlacement $placement (optional)
     * @param  \OpenAPI\Client\Model\LoggingFormatVersion $format_version (optional)
     * @param  string $response_condition The name of an existing condition in the configured endpoint, or leave blank to always execute. (optional)
     * @param  string $format A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats). (optional, default to '%h %l %u %t "%r" %&gt;s %b')
     * @param  \OpenAPI\Client\Model\LoggingMessageType $message_type (optional)
     * @param  string $timestamp_format Date and time in ISO 8601 format. (optional)
     * @param  int $period How frequently log files are finalized so they can be available for reading (in seconds). (optional, default to 3600)
     * @param  int $gzip_level What level of gzip encoding to have when sending logs (default &#x60;0&#x60;, no compression). If an explicit non-zero value is set, then &#x60;compression_codec&#x60; will default to \\\&quot;gzip.\\\&quot; Specifying both &#x60;compression_codec&#x60; and &#x60;gzip_level&#x60; in the same API request will result in an error. (optional, default to 0)
     * @param  \OpenAPI\Client\Model\LoggingCompressionCodec $compression_codec (optional)
     * @param  string $address An hostname or IPv4 address. (optional)
     * @param  string $hostname Hostname used. (optional)
     * @param  string $ipv4 IPv4 address of the host. (optional)
     * @param  string $password The password for the server. For anonymous use an email address. (optional)
     * @param  string $path The path to upload log files to. If the path ends in &#x60;/&#x60; then it is treated as a directory. (optional)
     * @param  int $port The port number. (optional, default to 21)
     * @param  string $public_key A PGP public key that Fastly will use to encrypt your log files before writing them to disk. (optional, default to 'null')
     * @param  string $user The username for the server. Can be anonymous. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateLogFtpRequest($service_id, $version_id, $logging_ftp_name, $created_at = null, $deleted_at = null, $updated_at = null, $service_id2 = null, $version = null, $name = null, $placement = null, $format_version = null, $response_condition = null, $format = '%h %l %u %t "%r" %&gt;s %b', $message_type = null, $timestamp_format = null, $period = 3600, $gzip_level = 0, $compression_codec = null, $address = null, $hostname = null, $ipv4 = null, $password = null, $path = null, $port = 21, $public_key = 'null', $user = null)
    {
        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling updateLogFtp'
            );
        }
        // verify the required parameter 'version_id' is set
        if ($version_id === null || (is_array($version_id) && count($version_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version_id when calling updateLogFtp'
            );
        }
        // verify the required parameter 'logging_ftp_name' is set
        if ($logging_ftp_name === null || (is_array($logging_ftp_name) && count($logging_ftp_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logging_ftp_name when calling updateLogFtp'
            );
        }

        $resourcePath = '/service/{service_id}/version/{version_id}/logging/ftp/{logging_ftp_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($version_id !== null) {
            $resourcePath = str_replace(
                '{' . 'version_id' . '}',
                ObjectSerializer::toPathValue($version_id),
                $resourcePath
            );
        }
        // path params
        if ($logging_ftp_name !== null) {
            $resourcePath = str_replace(
                '{' . 'logging_ftp_name' . '}',
                ObjectSerializer::toPathValue($logging_ftp_name),
                $resourcePath
            );
        }

        // form params
        if ($created_at !== null) {
            $formParams['created_at'] = ObjectSerializer::toFormValue($created_at);
        }
        // form params
        if ($deleted_at !== null) {
            $formParams['deleted_at'] = ObjectSerializer::toFormValue($deleted_at);
        }
        // form params
        if ($updated_at !== null) {
            $formParams['updated_at'] = ObjectSerializer::toFormValue($updated_at);
        }
        // form params
        if ($service_id2 !== null) {
            $formParams['service_id'] = ObjectSerializer::toFormValue($service_id2);
        }
        // form params
        if ($version !== null) {
            $formParams['version'] = ObjectSerializer::toFormValue($version);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($placement !== null) {
            $formParams['placement'] = ObjectSerializer::toFormValue($placement);
        }
        // form params
        if ($format_version !== null) {
            $formParams['format_version'] = ObjectSerializer::toFormValue($format_version);
        }
        // form params
        if ($response_condition !== null) {
            $formParams['response_condition'] = ObjectSerializer::toFormValue($response_condition);
        }
        // form params
        if ($format !== null) {
            $formParams['format'] = ObjectSerializer::toFormValue($format);
        }
        // form params
        if ($message_type !== null) {
            $formParams['message_type'] = ObjectSerializer::toFormValue($message_type);
        }
        // form params
        if ($timestamp_format !== null) {
            $formParams['timestamp_format'] = ObjectSerializer::toFormValue($timestamp_format);
        }
        // form params
        if ($period !== null) {
            $formParams['period'] = ObjectSerializer::toFormValue($period);
        }
        // form params
        if ($gzip_level !== null) {
            $formParams['gzip_level'] = ObjectSerializer::toFormValue($gzip_level);
        }
        // form params
        if ($compression_codec !== null) {
            $formParams['compression_codec'] = ObjectSerializer::toFormValue($compression_codec);
        }
        // form params
        if ($address !== null) {
            $formParams['address'] = ObjectSerializer::toFormValue($address);
        }
        // form params
        if ($hostname !== null) {
            $formParams['hostname'] = ObjectSerializer::toFormValue($hostname);
        }
        // form params
        if ($ipv4 !== null) {
            $formParams['ipv4'] = ObjectSerializer::toFormValue($ipv4);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($path !== null) {
            $formParams['path'] = ObjectSerializer::toFormValue($path);
        }
        // form params
        if ($port !== null) {
            $formParams['port'] = ObjectSerializer::toFormValue($port);
        }
        // form params
        if ($public_key !== null) {
            $formParams['public_key'] = ObjectSerializer::toFormValue($public_key);
        }
        // form params
        if ($user !== null) {
            $formParams['user'] = ObjectSerializer::toFormValue($user);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Fastly-Key');
        if ($apiKey !== null) {
            $headers['Fastly-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
